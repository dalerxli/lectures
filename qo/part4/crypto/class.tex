%% -*- coding:utf-8 -*- 
\section{Классическая криптография. Проблемы классической криптографии}
С того момента, как была осознана важность информации, стали появляться
средства ее защиты. 
%% Одними из первых кто стал применять методы
%% защиты информации были древние греки. Для этих целей они использовали
%% первую шифровальную машину - скитал. Скитал представлял собой
%% конусообразную дубинку на которую наматывалась
%% полоска кожи. В дальнейшем на коже писалось сообщение. Когда полоску кожи
%% снимали, то записи на ней представляли собой некоторую перестановку
%% символов исходного сообщения - шифротекст. 

%% С тех пор наука о защите информации, которая называется
%% криптографией проделала очень большой путь. 
Изобретались новые методы
шифрования, такие например, как шифр Цезаря, в котором каждая буква
алфавита заменялась на другую (например, следующую через три позиции в
алфавите после нее). Наряду с новыми методами шифрования появлялись
способы вскрытия этих шифров, например для шифра Цезаря можно
воспользоваться статистическими свойствами языка, на котором
писалось исходное сообщение.

Очень часто безопасность шифра обеспечивалась тем, что алгоритм, по
которому обеспечивалось шифрование, держался в секрете, как например в
рассмотренном выше шифре Цезаря. В современной классической
криптографии чаще всего алгоритмы
публикуются и доступны для изучения каждому. Секретность
обеспечивается тем, что само сообщение смешивается с секретным ключом
по некоторому открытому алгоритму. 

Допустим нам надо передать некоторое сообщение от Алисы к Бобу по
некоторому защищенному каналу связи. Сообщение должно быть
представлено в некоторой цифровой форме.
Протокол, описывающий такую
передачу, состоит из нескольких этапов. На первом Алиса и Боб должны
получить некоторую общую случайную последовательность чисел, которая
будет называться ключом. Эта процедура называется распределением
ключа. 

На следующем этапе Алиса должна с помощью
некоторого алгоритма $E$ получить из исходного сообщения $P$ и ключа $K$
зашифрованное сообщение $C$. Данная процедура может быть описана следующим
соотношением: 
\begin{equation}
E_{K}\left(P\right) = C.
\label{eqPart3CryptoEncryptClass}
\end{equation}

На третьем этапе полученное зашифрованное сообщение должно быть
передано Бобу.

На последнем этапе Боб с помощью известного алгоритма $D$ и полученного на
первом этапе ключа $K$ должен восстановить исходное сообщение $P$ из
полученного зашифрованного $C$. Данная процедура может быть описана
следующим соотношением
\begin{equation}
D_{K}\left(C\right) = P.
\label{eqPart3CryptoDeEncryptClass}
\end{equation}

При анализе данного протокола возникают следующие вопросы. Как
реализовать безопасное распределение ключа. Второй - существует ли
абсолютно стойкий алгоритм. И наконец последний - возможна ли
безопасная передача зашифрованного сообщения, когда оно не может быть
прослушано или подменено. 

Классическая криптография дает однозначный ответ только на второй
вопрос. Абсолютно криптостойкий алгоритм существует - он носит название
одноразового блокнота. Ниже представлено детальное описание этого алгоритма.

\subsection{Одноразовый блокнот}

Схема одноразового блокнота была предложена в 1917 году Мэйджором
Дж. Моборном и Г. Вернамом. Классический одноразовый блокнот представляет собой
некоторый набор случайных ключей, каждый из которых равен по размеру
отправляемому сообщению и используется только один раз. 

Предположим что мы хотим зашифровать сообщение на некотором языке
(например на английском). Число символов (букв) которое используется в
алфавите обозначим через $X$. Для английского языка (без знаков
препинания и различия регистра) $X = 26$. Далее каждому из символов
языка мы назначим некоторое число $c$, такое что $0 \le c \le
X$. Например для английского языка можно записать
\begin{equation}
\begin{array}{c}
A \rightarrow 0 \\
B \rightarrow 1 \\
\dots \\
Z \rightarrow 25 \\
\end{array}
\nonumber
\end{equation}
  
Процедура шифрования (\ref{eqPart3CryptoEncryptClass}) описывается
следующим выражением
\begin{equation}
E_{K_i}\left(P_i\right) = P_i + K_i mod X = C_i,
\label{eqPart3CryptoEncryptVernam}
\end{equation}
где $i$ номер шифруемого символа.

Процедура дешифрования (\ref{eqPart3CryptoDeEncryptClass}) описывается
следующим выражением
\begin{equation}
D_{K_i}\left(C_i\right) = C_i - K_i mod X = P_i,
\label{eqPart3CryptoDeEncryptVernam}
\end{equation}
где $i$ номер шифруемого символа.

Эта процедура легко обобщается на случай двоичных данных, при этом
вместо сложения по модулю используется операция XOR ($a \oplus b$) как
для шифрования, так и для дешифрования :
\begin{table}
\centering
\begin{tabular}{|c|c|c|}
\hline
$a$ & $b$ & $a \oplus b$ \\ \hline
0  & 0 & 0 \\
0  & 1 & 1 \\
1  & 0 & 1 \\
1  & 1 & 0 \\ \hline
\end{tabular}
\caption{XOR $a \oplus b$}
\label{tblXOR}
\end{table}

Клод Шенон показал \cite{bShenonCrypto}, что если ключ действительно
случайный, имеет такую 
же длину, как исходное сообщение, и не используется повторно, то
предложенная 
схема одноразового блокнота абсолютно защищена.

Согласно Шенону абсолютная защищенность (perfect security) может быть
определена следующим образом.
\begin{definition}
Шифр $\left(E, D\right)$ абсолютно защищен если для любых двух
сообщений одинаковой длины $m_0$ и $m_1$, некоторого шифротекста $c$ и
ключа $k \leftarrow_R K$ вероятности того что исходный текст $m_0$ или
$m_1$ равны:
\begin{equation}
P\left(E\left(m_0, k\right) = c \right) = 
P\left(E\left(m_1, k\right) = c \right)
\nonumber
\end{equation}
\end{definition}
Перефразируя это определение можно сказать, что по исходной статистике
шифротекста невозможно получить никакой информации об исходном
сообщении. 

\begin{theorem}
\emph{(Криптостойкость одноразового блокнота)}
Схема одноразового блокнота имеет абсолютную защищеность.
\end{theorem}

\begin{proof}
Обозначим через $\left|K\right|$ - число всех возможных ключей длины
$l$. Где $l$ также длина исходных сообщений: $\left|m_{0,1}\right| =
l$. В силу того, что ключ которым зашифровано сообщение определяется
единственным образом:
\begin{equation}
k_{0,1} = c \oplus m_{0,1},
\nonumber
\end{equation} 
получаем для вероятностей
\begin{equation}
P\left(E\left(m_0, k\right) = c \right) = 
P\left(E\left(m_1, k\right) = c \right) = 
\frac{1}{\left|K\right|}.
\nonumber
\end{equation}
\end{proof}


\subsection{Проблемы классической криптографии}

Если существует абсолютно защищенная криптографическая система (одноразовый блокнот) то
что же не так в классической криптографии? Проблема заключается в
получении ключей, удовлетворяющих требованиям одноразового блокнота
(длина ключа равна длине сообщения, ключ состоит из случайных данных и
ни разу не используется повторно) и передачи этих ключей Бобу и Алисе.

Проблемы возникают как на этапе генерации ключей, \footnote{получение больших
последовательностей случайных чисел является не тривиальной
математической задачей} так и на этапе передачи этих ключей. 

Для передачи ключей в классической криптографии используются так
называемые алгоритмы с открытым ключом. Существует несколько
протоколов обмена ключей, основанных на криптографических системах с
открытым ключом. Все они основаны на том, что существует два ключа,
первый из которых, называемый открытым (public key), используется только
для зашифрования, а второй - закрытый (private key) для дешифрования. 
Для того чтобы получить закрытый ключ из открытого,
необходимо произвести какую-то сложную математическую
операцию. Например безопасность одной из наиболее популярных систем с
открытым ключом - RSA(см. \ref {AddRSA}), основана на трудности
факторизации\footnote{разложении на простые множители} больших чисел.

Схема протокола распределения ключа, основанная на криптографии с
открытым ключом, может быть описана следующим образом. На первом этапе
Алиса создает открытый и закрытый ключи и первый из них отсылает Бобу. 
Боб со своей стороны создает тот ключ, который хотелось бы иметь и
Алисе и Бобу (который требуется распределить). Этот ключ шифруется
(например по RSA) с помощью открытого ключа Алисы и пересылается
ей. Алиса, получая этот зашифрованный ключ, может расшифровать его с
помощью своего закрытого ключа.

Если злоумышленник (Ева) хочет узнать передаваемый ключ, она должна
решить сложную математическую задачу по факторизации больших
чисел. Считается, но не доказано, что сложность факторизации растет
экспоненциально с ростом числа цифр в числе
\cite{bPhisQuantInfo}.\footnote{Наиболее быстрый из известных
  алгоритмов решает задачу о факторизации числа $N$ за время порядка
  $O\left(exp\left(log^{\frac{1}{3}}N\left(log \, log N\right)^{\frac{2}{3}}\right)\right)$.} 
Таким образом при увеличении числа цифр задача быстро становится не решаемой.

В этой схеме имеется несколько проблем. Первая связана с тем что
сложность факторизации не доказана. Мало того, существуют алгоритмы для
квантовых компьютеров - алгоритм Шора(см. \ref {Part4QuantCompShor}),
которые решают задачу о факторизации числа $N$ за время $O\left(log
N\right)$, т. е. за время порядка числа цифр в $N$. Таким образом в
тот момент, когда будет построен квантовый компьютер, все системы,
основанные на RSA, утратят свою актуальность. 

%% Существует еще одна проблема которая делает системы распределения
%% ключа основанные на открытой криптографии незащищенными. Представим
%% себе ситуацию когда Ева может перехватывать все сообщения Алисы и Боба
%% и подменять их своими, что не является абсолютно нерешаемой задачей в
%% классической теории связи. В этом случае Ева может представиться Бобом для
%% Алисы и Алисой для Боба и таким образом полностью контролировать
%% передачу сообщений между ними и в момент пересылки ключа она сможет
%% его расшифровать. 
