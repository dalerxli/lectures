%% -*- coding:utf-8 -*- 
\section{Основные принципы квантовых вычислений}

\subsection{Представление информации. Классические и квантовые
  состояния}
Основное отличие квантовых и классических компьютеров заключается в
том как они хранят информацию. 

В классическом случае информация хранится в некоторых ячейках
памяти. Состояние каждой ячейки памяти описывается одним числом
которое может принимать значение 0 или 1. Если объединяются $m$ ячеек
памяти то общее состояние классической системы (которое она может
принимать в конкретный момент времени) описывается $m$ числами.

В квантовом случае ячейка памяти представлена кубитом для описания
которого необходимо два комплексных числа $\alpha_0$ и $\alpha_1$
\footnote{Более правильно говорить тремя вещественными числами, потому
что на $\alpha_{0,1}$ действует следующее ограничение 
$\left|\alpha_0\right|^2 + \left|\alpha_1\right|^2 = 1$ откуда с
учетом $\alpha_{0,1} = r_{0,1}e^{i \theta_{0,1}}$ получим что $r_0^2 =
1 - r_1^2$}:
\[
\left|\psi\right>_1 = \alpha_0 \ket{ 0 } + \alpha_1 \ket{ 1 }.
\]
Для описания составной системы состоящей из $m$ кубитов необходимо
$2^m$ комплексных чисел. Иначе можно сказать что квантовое состояние
содержит в качестве суперпозиции все возможные классические
состояния. В качестве примера можно рассмотреть систему состоящию из 3
кубитов:
\begin{eqnarray}
\left|\psi\right>_3 = 
\alpha_0 \ket{ 000 } + 
\alpha_1 \ket{ 001 } + 
\alpha_2 \ket{ 010 } + 
\alpha_3 \ket{ 011 } + 
\nonumber \\
+ 
\alpha_4 \ket{ 100 } + 
\alpha_5 \ket{ 101 } + 
\alpha_6 \ket{ 110 } + 
\alpha_7 \ket{ 111 }.
\label{eqQuantCompPrinciplePsi8}
\end{eqnarray}
Как видно любое классическое состояние системы из 3 бит представлено в
качестве одного из членов суперпозиции
\eqref{eqQuantCompPrinciplePsi8}. Например число $5_{10}=101_2$ входит
в \eqref{eqQuantCompPrinciplePsi8} с коэфициентом $\alpha_5$.

\subsection{Обратимые вычисления}

\input ./part4/quantcomp/figclasscomp.tex

В классическом случае вычисление состоит в преобразовании исходных $n$
битов в результат, описываемый $m$ битами
(см. \autoref{figQuantCompClassComp}). Преобразование при этом
задается некоторой функцией $f\left(x\right)$. Типичный пример -
сложение по модулю 2 (см. табл. \ref {tblXOR}) в котором на входе имеем 2 бита
($n = 2$), а на выходе - 1 бит ($m = 1$).

\input ./part4/quantcomp/figquantcomp.tex

Такая схема не будет работать в квантовом случае прежде всего потому
что изменение чистых квантовых состояний во времени должно
осуществятся посредством унитарного оператора эволюции
\eqref{eqAddDiracEvolutionOper}, т. е. должно быть обратимым что для
нашего классического примера невозможно \footnote{невозможно получить
  из одного бита (результат) два бита исходной информации}. В силу
этого в квантовых вычислениях  используют другую схему
(см. \autoref{figQuantCompQuantComp}) при которой возможны обратимые
вычисления.  

На вход вместе с исходными данными $x$ описываемыми $n$ кубитами
подаются $m$ кубитов в состоянии $\ket{0}$, таким
образом чтобы общее число входов и выходов соответствовало друг
другу. Следовательно связь между входом и выходом может быть описана в
ввиде
\footnote{Более правильно записывать в общем виде как 
$
\underbrace{\ket{x}}_n
\underbrace{\left|f\left(x\right)\right>}_m
\underbrace{\ket{r}}_k = 
\hat{U}_f \underbrace{\ket{x}}_n
\underbrace{\left|0 \dots 0\right>}_{m+k},
$
где $\ket{r}$ остаток размером $k$ кубит который не
используется в вычислениях и служит цели обеспечения унитарности
оператора $\hat{U}_f$
}
\begin{equation}
\underbrace{\ket{x}}_n
\underbrace{\left|f\left(x\right)\right>}_m = 
\hat{U}_f \underbrace{\ket{x}}_n\underbrace{\left|0 \dots
  0\right>}_m.
\label{eqQuantCompQuantComp}
\end{equation}

