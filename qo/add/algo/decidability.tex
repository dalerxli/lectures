%% -*- coding:utf-8 -*-
\section{Теория вычислимости}

Машина Тьюринга $M$ (см. рис. \ref{figAddAlgoDecidability}) может
трактоваться как некоторая функция $m$ в качестве 
аргумента которой является набор символов представляющий собой
начальное состояние ленты $x$. В результате обработки $x$ машина $M$
может завершить свою работу, т. е. оказаться в некотором финальном
состоянии $f \in F \subset Q$. В этом случае говорят, что $M$
принимает $x$. В этом случае значение соответствующей функции 
$m(x) = 1$. 

При этом вычисление функции $m(x)$ может трактоваться как некоторая
задача.  
\begin{definition}[Задача]
Будем называть задачей относительно машины Тьюринга ответ да/нет на
вопрос об некотором множестве возможных объектов
\end{definition}

\begin{example}
\emph{Гамильтонов граф}
Задача о гамильтоновом графе - для заданного графа существует или нет
путь (цепь) содержащий каждую вершину этого графа только один раз.
\nonumber
\end{example}

\input ./add/algo/figdecidability.tex

%% \begin{definition}[Язык $L\left(M\right)$ машины Тьюринга $M$]
%% Множество исходных данных $x$ для которых машина Тьюринга $M$ завершает
%% свою работу (terminate) называется языком $L\left(M\right)$. Т. е.  
%% $\forall x \in L\left(M\right): m(x) = 1$.
%% \end{definition}

В случае зависания (halt) $M$, т. е. когда $M$
оказывается в состоянии дальнейший переход из которого не определен,
говорят, что $M$ отвергает $x$. В этом случае значение соответствующей
функции $m(x) =0$. 

Так же машина $M$ на входе $x$ может никогда не
завершить свою работу. В этом случае значение функции $m(x)$
не определено.    

\begin{definition}[Рекурсивный язык (Recursive language)]
Множество строк $L$
\footnote{множество начальных состояний ленты некоторой
машины Тьюринга}
называется рекурсивным языком если существует машина Тьюринга $M$
такая, что $\forall x \in L$ соответствующая функция $m(x) = 1$, а 
$\forall x \notin L$ соответствующая функция $m(x) = 0$. 
\end{definition}

Т. о. $M$ соответствующая рекурсивному языку $L\left(M\right)$ 
останавливается на любых исходных данных. Множество рекурсивных языков
обозначается $R$.

\begin{definition}[Рекурсивно перечислимый язык (Recursively
    enumerable language)] 
Множество строк $L$
называется рекурсивно перечислимым языком если существует машина Тьюринга $M$
такая, что $\forall x \in L$ $M$ завершает свою работу в некотором
финальном состоянии, т. е. соответствующая функция $m(x) = 1$. 
\end{definition}

Т. о. $M$ соответствующая рекурсивно перечислимому языку $L\left(M\right)$ 
останавливается на любых исходных данных принадлежащих языку, но при
этом может никогда не завершить свою работу при исходных данных не
принадлежащих языку $L\left(M\right)$. Множество рекурсивно
перечислимых языков обозначается $RE$. Очевидно  $R \subset RE$.

Машина Тьюринга задает класс функций для которых можно определить
такое понятие как вычислимость. 

\begin{definition}[Вычислимая функция
\footnote{
На самом деле понятие вычислимости не может быть определено строго
математически и дается здесь в формулировке тезиса Чёрча - Тьюринга
}]
Функция $m$ называется вычислимой, а соответствующая ей задача -
разрешимой, если для нее существует некоторая
машина Тьюринга $M$, а соответствующий этой машине язык является
рекурсивным $L\left(M\right) \in R$. В противном случае соответствующая
задача называется не разрешимой.
\end{definition}

\begin{theorem}[Теорема о мощности множества машин Тьюринга]
Множество машин Тьюринга счетно.
\label{theoremAddAlgoTuringCountability}
\end{theorem}

\begin{proof}
Множество называется счетным \cite{bShenSet2012} если каждому его
элементу можно поставить 
в соответствие некоторое натуральное число. 
Машина Тьюринга взаимно однозначно определяется следующей группой элементов
\begin{itemize}
\item Множество состояний $Q$
\item Начальное состояние $q_0$
\item Множество финальных состояний $F \subset Q$
\item Алфавит $\Sigma$
\item Таблица переходов $\Delta$
\end{itemize}

В силу того, что каждый из перечисленных элементов машины Тьюринга
принимает ограниченное число значений, то каждому элементу, а
следовательно и всей машине Тьюринга, можно поставить некоторое
уникальное (для соответствующей машины) число
\footnote{
Например можно закодировать каждую машину уникальной
последовательностью чисел $0$ и $1$. Полученная последовательность
будет конечной в силу конечности множества элементов из которых
состоит машина Тьюринга. Любой конечной последовательности чисел $0$ и
$1$ соответствует уникальное натуральное число, для которого
рассматриваемая последовательность является двоичной записью. 
}, что доказывает счетность
множества всех машин Тьюринга.
\end{proof}

После введения понятия вычислимой функции стает вопрос о вычислимости
произвольной функции. Допустим у нас имеется некоторые исходные данные
(аргумент функции) $x$ существует ли такая машина Тьюринга $M$ которая
принимает эти данные, т. е. $M$ завершит свою работу в некотором
финальном состоянии. Ответ на этот вопрос дает следующая теорема

\begin{theorem}[Теорема о невычислимости]
Существует такой язык $L_d$ который не принимает ни одна машина
Тьюринга, т. е. соответствующая $L_d$ задача является принципиально
неразрешимой (не вычислимой) 
\label{theoremAddAlgoTuringLdUndecidability}
\end{theorem}

Язык $L_d$ часто называют диагональным языком (diagonalization
language), потому что если составить матрицу 
\cite{bUllman2006} индексы строк которой
будут задавать номера исходных данных машин Тьюринга, а номера
столбцов будут соответствовать номер машин Тьюринга. Значение этой
матрицы $a_{ij}$ будет равно $1$ если $M_J$ содержит $x_i$ и $0$ в
противном случае. Инвертированные \footnote{ $0$ заменен на $1$, а $1$
на $0$} числа на диагонали будут определять язык $L_d$.

\begin{proof}
В силу теоремы \ref{theoremAddAlgoTuringCountability} можно говорить о
$i$-ой машине Тьюринга $M_i$, где $i$ - некоторое натуральное
число. Допустим $x_i$ строка которая не распознается $M_i$, т. е. 
$x_i \notin L\left(M_i\right)$. Строки $x_i$ образуют некоторый язык
$L_d$. В силу определения языка $L_d$ не существует машины Тьюринга,
которая бы принимала все строки этого языка.
\end{proof}

\begin{definition}[Универсальная машина Тьюринга]
Универсальная машина Тьюринга $M_u$ это такая машина, которая получив
на входе строку $x$ и код для некоторой машины Тьюринга $M$ вычисляет
результат применения $x$ на $M$.
\end{definition}

\input ./add/algo/figuturing.tex

Множество пар строк $\left(x, M\right)$ образуют некоторый язык $L_U$ машины
$M_U$. 

\input ./add/algo/figuturingproof.tex

\begin{theorem}[Теорема о языке универсальной машины Тьюринга]

Язык универсальной машины Тьюринга является рекурсивно перечислимым и
не является рекурсивным, т. е. $L_U \in RE$ и $L_U \notin R$. Таким
образом задача распознавания языка универсальной машины Тьюринга
является не разрешимой.
\label{theoremAddAlgoTuringUniversalMachine}
\end{theorem}

\begin{proof}
Утверждение $L_U \in RE$ прямо вытекает из определения универсальной
машины Тьюринга: если $M$ принимает $x$ то и $M_U$ принимает пару
строк $\left(x, M\right)$.

Утверждения $L_U \notin R$ докажем от противного, т. е. допустим, что
$L_U \in R$. Построим с помощью такой машины $M_U$ машину Тьюринга
$M_d$ которая будет принимать все строки языка $L_d$. Для каждой строчки
$x_i \in L_d$ можно поставить в соответствие некоторую машину Тьюринга
$M_i$ которая не принимает эту строчку, т. е. $x_i \notin
L\left(M_i\right)$. Пара значений $\left(x_i, M_i\right)$ может быть
подана на вход универсальной машины Тьюринга как это показано на рис. 
\ref{figAddAlgoUTuringProof}. Если $L_U \in R$ то машина $M_U$ может
решить принимает $M_i$ исходные данные $x_i$ или нет. Если $M_i$ не
принимает $x_i$, то машина $M_d$ должна принять эти данные. Таким
образом построена машина Тьюринга $M_d$ которая принимает все строки
$x_i \in L_d$ и отвергает все строки $x_i \notin L_d$, что невозможно
в силу теоремы \ref{theoremAddAlgoTuringLdUndecidability}
\end{proof}

Каждая машина Тьюринга $M$ имеет некоторый код который может быть 
интерпретирован как исходные данные для другой машины Тьюринга $M_P$. 
Машина может как принять так и отвергнуть этот код. В силу взаимной
однозначности соответствия между машиной Тьюринга $M$ и языком 
$L\left(M\right)$, можно говорить о машине Тьюринга
которая принимает либо отвергает языки $L$. Если машина $M_P$
принимает некоторое множество языков, то говорят, 
%FIXME!!! проверь это
что эти языки обладают некоторым свойством $P$.

\begin{definition}[Нетривиальное свойство языка машины Тьюринга]
Свойство языка называется нетривиальным если среди всех языков можно
выделить как те которые удовлетворяют данному свойству так и те
которые ему не удовлетворяют.
\end{definition}

\begin{theorem}[Теорема Райса]
Задача об определении любого нетривиального свойства языка 
$L\left(M\right)$ машины Тьюринга $M$ является неразрешимой задачей
\end{theorem}

\begin{proof}
Допустим, что мы имеем машину $M_P$ которая может определять
некоторое нетривиальное свойство языков $P$, т. е. она может
распределить языки всех 
машин Тьюринга в два множества (каждое из которых является непустым). 
Первое из этих множеств содержит все языки удовлетворяющие $P$ ($M_P$
принимает языки из этого множества), а второе - все языки которые не
удовлетворяют свойству $P$. 

\input ./add/algo/figrice.tex

Попробуем построить на базе $M_P$ универсальную машину Тьюринга $M_U$,
которая принимает (или отвергает) пары $\left(x, M\right)$ 
(см. рис. \ref{figAddAlgoRiceTheorem}).

Допустим мы имеем машину $M_L$ которая принимает строки $l$ из
некоторого языка $L$
\footnote{Никакой взаимосвязи между языком $L$ и свойством $P$ на этом шаге}.

В качестве первого шага построим машину $M'$, которая принимает строки
$l$. При этом пара $\left(x, M\right)$ считается заданной и встроена в
код $M'$. Ключевым свойством $M'$ является следующее: $M'$ принимает
строки $д \in L$ в том и только том случае если $M$ 
принимает $x$. Таким образом возможны два случая:
\begin{itemize}
\item $L(M') = L(M_L)$ если $M'$ принимает $l$ как результат приема
  пары $\left(x, M\right)$ 
\item $L(M') = \emptyset$ если $M'$ отвергает любые исходные данные
  $l$,
т. е. в случае если $M$ никогда не завершает свою работу при исходных
данных $x$ 
\end{itemize}

На следующем шаге вспомним про свойство $P$ и допустим, что язык $L$
(который принимает машина $M'$) имеет свойство $P$, т. е. $L \in
P$. Также предположим, что $\emptyset \notin P$
\footnote{
Если $\emptyset \in P$ тогда можно рассмотреть свойство 
$\bar{P} = \left\{\forall L: L \notin P\right\}$. В этом случае
$\emptyset \notin \bar{P}$
}. 
Т. о. если подать код
для $M'$ на вход машины $M_p$, то $M_p$ примет исходные данные (код
$M'$) если $L(M') \in P$ и отклонит их если $L(M') = \emptyset$.

С другой стороны пара $\left(x, M\right)$ встроена в исходный код
$M'$, т. е. можно полагать что $M_P$ получает на вход именно пару 
$\left(x, M\right)$ и принимает ее если $M$ принимает $x$
($L\left(M'\right) \in P$) и отвергает
эту пару если $M$ не принимает $x$ 
($L\left(M'\right) = \emptyset \notin P$). Таким образом с помощью
$M_P$ мы построили универсальную машину Тьюринга и показали что ее
язык является рекурсивным, что невозможно в силу теоремы 
\ref{theoremAddAlgoTuringUniversalMachine}.
\end{proof}

