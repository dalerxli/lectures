%% -*- coding:utf-8 -*-
\section{Теория вычислимости}

Машина Тьюринга $M$ (см. рис. \ref{figAddAlgoDecidability}) может
трактоваться как некоторая функция $m$ в качестве 
аргумента которой является набор символов представляющий собой
начальное состояние ленты $x$. В результате обработки $x$ машина $M$
может завершить свою работу, т. е. оказаться в некотором финальном
состоянии $f \in F \subset Q$. В этом случае говорят, что $M$
принимает $x$. В этом случае значение соответствующей функции 
$m(x) = 1$. 

\input ./add/algo/figdecidability.tex

\begin{definition}[Язык $L\left(M\right)$ машины Тьюринга $M$]
Множество исходных данных $x$ для которых машина Тьюринга $M$ завершает
свою работу (terminate) называется языком $L\left(M\right)$. Т. е.  
$\forall x \in L\left(M\right): m(x) = 1$.
\end{definition}

В случае зависания (halt) $M$, т. е. когда $M$
оказывается в состоянии дальнейший переход из которого не определен,
говорят, что $M$ отвергает $x$. В этом случае значение соответствующей
функции $m(x) =0$. 

Так же машина $M$ на входе $x$ может никогда не
завершить свою работу. В этом случае значение функции $m(x)$
не определено.    

\begin{definition}[Рекурсивный язык (Recursive language)]
Множество строк $L$
\footnote{множество начальных состояний ленты некоторой
машины Тьюринга}
называется рекурсивным языком если существует машина Тьюринга $M$
такая, что $\forall x \in L$ соответствующая функция $m(x) = 1$, а 
$\forall x \notin L$ соответствующая функция $m(x) = 0$. 
\end{definition}

Т. о. $M$ соответствующая рекурсивному языку $L\left(M\right)$ 
останавливается на любых исходных данных. Множество рекурсивных языков
обозначается $R$.

\begin{definition}[Рекурсивно перечислимый язык (Recursively enumerable language)]
Множество строк $L$
называется рекурсивно перечислимым языком если существует машина Тьюринга $M$
такая, что $\forall x \in L$ $M$ завершает свою работу в некотором
финальном состоянии, т. е. соответствующая функция $m(x) = 1$. 
\end{definition}

Т. о. $M$ соответствующая рекурсивно перечислимому языку $L\left(M\right)$ 
останавливается на любых исходных данных принадлежащих языку, но при
этом может никогда не завершить свою работу при исходных данных не
принадлежащих языку $L\left(M\right)$. Множество рекурсивно
перечислимых языков обозначается $RE$. Очевидно  $R \subset RE$.

Машина Тьюринга задает класс функций для которых можно определить
такое понятие как вычислимость. 

\begin{definition}[Вычислимая функция
\footnote{
На самом деле понятие вычислимости не может быть определено строго
математически и дается здесь в формулировке тезиса Чёрча - Тьюринга
}]
Функция $m$ называется вычислимой, а соотвествующая ей задача -
разрешимой, если для нее существует некоторая
машина Тьюринга $M$, а соответствующий этой машине язык является
рекурсивным $L\left(M\right) \in R$. В противном случае соотвествующая
задача называется не разрешимой.
\end{definition}

\begin{theorem}
\emph{(Теорема о мощности множества машин Тьюринга)}
Множество машин Тьюринга счетно.
\label{theoremAddAlgoTuringCountability}
\end{theorem}

\begin{proof}
Множество называется счетным если каждому его элементу можно поставить
в соответствие некоторое натуральное число. 
Машина Тьюринга взаимно однозначно определяется следующей группой элементов
\begin{itemize}
\item Множество состояний $Q$
\item Начальное состояние $q_0$
\item Множество финальных состояний $F \subset Q$
\item Алфавит $\Sigma$
\item Таблица переходов $\Delta$
\end{itemize}

В силу того, что каждый из перечисленных элементов машины Тьюринга
принимает ограниченное число значений, то каждому элементу, а
следовательно и всей машине Тьюринга, можно поставить некоторое
уникальное (для соответствующей машины) число
\footnote{
Например можно закодировать каждую машину уникальной
последовательностью чисел $0$ и $1$. Полученная последовательность
будет конечной в силу конечности множества элементов из которых
состоит машина Тьюринга. Любой конечной последовательности чисел $0$ и
$1$ соответствует уникальное натуральное число, для которого
рассматриваемая последовательность является двоичной записью. 
}, что доказывает счетность
множества всех машин Тьюринга.
\end{proof}

После введения понятия вычислимой функции стает вопрос о вычислимости
произвольной функции. Допустим у нас имеется некоторые исходные данные
(аргумент функции) $x$ существует ли такая машина Тьюринга $M$ которая
принимает эти данные, т. е. $M$ завершит свою работу в некотором
финальном состоянии. Ответ на этот вопрос дает следующая теорема

\begin{theorem}
\emph{(Теорема о невычислимости)}
Существует такой язык $L_d$ который не принимает ни одна машина
Тьюринга, т. е. соотвествующая $L_d$ задача является принципиально
неразрешимой (не вычислимой) 
\label{theoremAddAlgoTuringLdUndecidability}
\end{theorem}

Язык $L_d$ часто называют диагональным языком (diagonalization
language), потому что если составить матрицу 
\cite{bUllman2006} индексы строк которой
будут задавать номера исходных данных машин Тьюринга, а номера
столбцов будут соотвествовать номер машин Тьюринга. Значение этой
матрицы $a_{ij}$ будет равно $1$ если $M_J$ содержит $x_i$ и $0$ в
противном случае. Инвертированные \footnote{ $0$ заменен на $1$, а $1$
на $0$} числа на диагонали будут определять язык $L_d$.

\begin{proof}
В силу теоремы \ref{theoremAddAlgoTuringCountability} можно говорить о
$i$-ой машине Тьюринга $M_i$, где $i$ - некоторое натуральное
число. Допустим $x_i$ строка которая не распознается $M_i$, т. е. 
$x_i \notin L\left(M_i\right)$. Строки $x_i$ образуют некоторый язык
$L_d$. В силу определения языка $L_d$ не существует машины Тьюринга,
которая бы принимала все строки этого языка.
\end{proof}

\begin{definition}[Универсальная машина Тьюринга]
Универсальная машина Тьюринга $M_u$ это такая машина, которая получив
на входе строку $x$ и код для некоторой машины Тьюринга $M$ вычисляет
результат применения $x$ на $M$.
\end{definition}

\input ./add/algo/figuturing.tex

Множество пар строк $\left(x, M\right)$ образуют некоторый язык $L_U$ машины
$M_U$. 

\input ./add/algo/figuturingproof.tex

\begin{theorem}
\emph{(Теорема о языке универсальной машины Тьюринга)}

Язык универсальной машины Тьюринга является рекурсивно перечислимым и
не является рекурсивным, т. е. $L_U \in RE$ и $L_U \notin R$. Таким
образом задача распознования языка универсальной машины Тьюринга
является не разрешимой.
\end{theorem}

\begin{proof}
Утверждение $L_U \in RE$ прямо вытекает из определения универсальной
машины Тьюринга: если $M$ принимает $x$ то и $M_U$ принимает пару
строк $\left(x, M\right)$.

Утвержение $L_U \notin R$ докажем от противного, т. е. допустим, что
$L_U \in R$. Построим с помощью такой машины $M_U$ машину Тьюринга
$M_d$ которая будет примать все строки языка $L_d$. Для каждой строчки
$x_i \in L_d$ можно поставить в соотвествие некоторую машину Тьюринга
$M_i$ которая не принимает эту строчку, т. е. $x_i \notin
L\left(M_i\right)$. Пара значений $\left(x_i, M_i\right)$ может быть
подана на вход универсальной машины Тьюринга как это показано на рис. 
\ref{figAddAlgoUTuringProof}. Если $L_U \in R$ то машина $M_U$ может
решить принимает $M_i$ исходные данные $x_i$ или нет. Если $M_i$ не
принимает $x_i$, то машина $M_d$ должна принять эти данные. Таким
образом построена машина Тьюринга $M_d$ которая принимает все строки
$x_i \in L_d$ и отвергает все строки $x_i \notin L_d$, что невозможно
в силу теоремы \ref{theoremAddAlgoTuringLdUndecidability}
\end{proof}

Каждая машина Тьюринга $M$ имеет некоторый код $L\left(M\right)$
который может быть 
интерпретирован как исходные данные для другой машины Тьюринга. Машина
может как принять так и отвергнуть этот код. В силу взаимной
однозначности соотвествия между машиной Тьюринга $M$ и языком ей
соотвествующим $L\left(M\right)$ можно говорить о машине Тьюринга
которая принимает либо отвергает языки $L$. Если такая машина Тьюринга
принимает некоторое множество языков, то говорят, 
%FIXME!!! проверь это
что эти языки обладают некоторым свойством.

\begin{definition}[Нетривиальное свойство языка машины Тьюринга]
Свойство языка называется нетривиальным если среди всех языков можно
выделить как те которые удовлетворяют данному свойству так и те
которые ему не удовлетворяют.
\end{definition}

\begin{theorem}
\emph{(Теорема Райса)}
Задача об определении любого нетривиального свойства языка 
$L\left(M\right)$ машины Тьюринга $M$ является неразрешимой задачей
\end{theorem}

\begin{proof}
Допустим, что мы имеем машину $M_P$ которая может определять
некоторое нетривиальное свойство языков $P$, т. е. она может
распределить языки всех 
машин Тьюринга в два множества (каждое из которых является непустым). 
Первое из этих множеств содержит все языки удовлетворяющие $P$ ($M_P$
принимает языки из этого множества), а
второе - все языки которые не удовлетворяют свойству $P$

The first one with languages satisfy the property ($M_P$
accepts a language from the set). The second one with languages which
don't have the property ($M_P$ rejects the languages from the
set). The proof idea to create a turing machine $M_U$ that
accepts/rejects $(M, \omega)$ pairs. 

Input data: we have a machine $M_L$ that accepts
language $L$. There is also a string $x \in L$. 
Note: No relation with property $P$ on the step.

First idea. Forgot about a language property $P$ and
machine $M_P$. We want to costruct a turing machine $M'$
with $x$ as input. 

Note: The pair $(M, \omega)$ is defined and fixed at the step
i. e. it's encoded into $M'$ code. 

$M'$ accepts string $x \in L$ iff the $M$
accepts $\omega$. Thus there are two cases 

$L(M') = L(M_L)$ if $M'$ accepts $x$ as result of pair $(M,
\omega)$ accept 
$L(M') = \emptyset$ if $M'$ does not accept any input $x$
i. e. when the $M$ will run forever on input $\omega$. 

Second idea. Now the time to remember about language and
property $P$. Lets the language $L$ has the property i.e. $L \in
P$. Second assumption - $\emptyset \notin P$. Thus $M_P$ runs
on $M'$ as input will accept $M'$ if $L(M') \in P$ and rejects
the input if $L(M') = \emptyset$ 

From other hand the pair $(M, \omega)$ is encoded into $M'$ code
thus the machine $M_P$ which takes $M'$ as input (or equally
pair $(M, \omega)$ ) can decide if the language described by the
machine is empty ($M$ runs forever on input $\omega$) or not empty
($M$ accepts $\omega$). As result we have constructed $M_U$. 
\end{proof}

